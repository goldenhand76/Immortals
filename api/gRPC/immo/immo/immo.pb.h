// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/gRPC/immo/immo.proto
// Protobuf C++ Version: 5.26.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fgRPC_2fimmo_2fimmo_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fgRPC_2fimmo_2fimmo_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 5026001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fgRPC_2fimmo_2fimmo_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fgRPC_2fimmo_2fimmo_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_api_2fgRPC_2fimmo_2fimmo_2eproto;
namespace immo {
class ActuatorResponse;
struct ActuatorResponseDefaultTypeInternal;
extern ActuatorResponseDefaultTypeInternal _ActuatorResponse_default_instance_;
class ListRequest;
struct ListRequestDefaultTypeInternal;
extern ListRequestDefaultTypeInternal _ListRequest_default_instance_;
class ListResponse;
struct ListResponseDefaultTypeInternal;
extern ListResponseDefaultTypeInternal _ListResponse_default_instance_;
class NodeRequest;
struct NodeRequestDefaultTypeInternal;
extern NodeRequestDefaultTypeInternal _NodeRequest_default_instance_;
class NodeResponse;
struct NodeResponseDefaultTypeInternal;
extern NodeResponseDefaultTypeInternal _NodeResponse_default_instance_;
class SensorResponse;
struct SensorResponseDefaultTypeInternal;
extern SensorResponseDefaultTypeInternal _SensorResponse_default_instance_;
}  // namespace immo
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace immo {

// ===================================================================


// -------------------------------------------------------------------

class SensorResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:immo.SensorResponse) */ {
 public:
  inline SensorResponse() : SensorResponse(nullptr) {}
  ~SensorResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SensorResponse(const SensorResponse& from) : SensorResponse(nullptr, from) {}
  inline SensorResponse(SensorResponse&& from) noexcept
      : SensorResponse(nullptr, std::move(from)) {}
  inline SensorResponse& operator=(const SensorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorResponse& operator=(SensorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorResponse* internal_default_instance() {
    return reinterpret_cast<const SensorResponse*>(
        &_SensorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(SensorResponse& a, SensorResponse& b) { a.Swap(&b); }
  inline void Swap(SensorResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SensorResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorResponse& from) { SensorResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "immo.SensorResponse"; }

 protected:
  explicit SensorResponse(::google::protobuf::Arena* arena);
  SensorResponse(::google::protobuf::Arena* arena, const SensorResponse& from);
  SensorResponse(::google::protobuf::Arena* arena, SensorResponse&& from) noexcept
      : SensorResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kTopicFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string topic = 2;
  void clear_topic() ;
  const std::string& topic() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topic(Arg_&& arg, Args_... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* value);

  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(
      const std::string& value);
  std::string* _internal_mutable_topic();

  public:
  // @@protoc_insertion_point(class_scope:immo.SensorResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr topic_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fgRPC_2fimmo_2fimmo_2eproto;
};
// -------------------------------------------------------------------

class NodeRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:immo.NodeRequest) */ {
 public:
  inline NodeRequest() : NodeRequest(nullptr) {}
  ~NodeRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeRequest(const NodeRequest& from) : NodeRequest(nullptr, from) {}
  inline NodeRequest(NodeRequest&& from) noexcept
      : NodeRequest(nullptr, std::move(from)) {}
  inline NodeRequest& operator=(const NodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeRequest& operator=(NodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeRequest* internal_default_instance() {
    return reinterpret_cast<const NodeRequest*>(
        &_NodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(NodeRequest& a, NodeRequest& b) { a.Swap(&b); }
  inline void Swap(NodeRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NodeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeRequest& from) { NodeRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "immo.NodeRequest"; }

 protected:
  explicit NodeRequest(::google::protobuf::Arena* arena);
  NodeRequest(::google::protobuf::Arena* arena, const NodeRequest& from);
  NodeRequest(::google::protobuf::Arena* arena, NodeRequest&& from) noexcept
      : NodeRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kAddressFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string address = 2;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:immo.NodeRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fgRPC_2fimmo_2fimmo_2eproto;
};
// -------------------------------------------------------------------

class ListRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:immo.ListRequest) */ {
 public:
  inline ListRequest() : ListRequest(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListRequest(const ListRequest& from) : ListRequest(nullptr, from) {}
  inline ListRequest(ListRequest&& from) noexcept
      : ListRequest(nullptr, std::move(from)) {}
  inline ListRequest& operator=(const ListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRequest& operator=(ListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRequest* internal_default_instance() {
    return reinterpret_cast<const ListRequest*>(
        &_ListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ListRequest& a, ListRequest& b) { a.Swap(&b); }
  inline void Swap(ListRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ListRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "immo.ListRequest"; }

 protected:
  explicit ListRequest(::google::protobuf::Arena* arena);
  ListRequest(::google::protobuf::Arena* arena, const ListRequest& from);
  ListRequest(::google::protobuf::Arena* arena, ListRequest&& from) noexcept
      : ListRequest(arena) {
    *this = ::std::move(from);
  }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:immo.ListRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_api_2fgRPC_2fimmo_2fimmo_2eproto;
};
// -------------------------------------------------------------------

class ActuatorResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:immo.ActuatorResponse) */ {
 public:
  inline ActuatorResponse() : ActuatorResponse(nullptr) {}
  ~ActuatorResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActuatorResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ActuatorResponse(const ActuatorResponse& from) : ActuatorResponse(nullptr, from) {}
  inline ActuatorResponse(ActuatorResponse&& from) noexcept
      : ActuatorResponse(nullptr, std::move(from)) {}
  inline ActuatorResponse& operator=(const ActuatorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActuatorResponse& operator=(ActuatorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActuatorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActuatorResponse* internal_default_instance() {
    return reinterpret_cast<const ActuatorResponse*>(
        &_ActuatorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ActuatorResponse& a, ActuatorResponse& b) { a.Swap(&b); }
  inline void Swap(ActuatorResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActuatorResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActuatorResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ActuatorResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActuatorResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActuatorResponse& from) { ActuatorResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ActuatorResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "immo.ActuatorResponse"; }

 protected:
  explicit ActuatorResponse(::google::protobuf::Arena* arena);
  ActuatorResponse(::google::protobuf::Arena* arena, const ActuatorResponse& from);
  ActuatorResponse(::google::protobuf::Arena* arena, ActuatorResponse&& from) noexcept
      : ActuatorResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kTopicFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string topic = 2;
  void clear_topic() ;
  const std::string& topic() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topic(Arg_&& arg, Args_... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* value);

  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(
      const std::string& value);
  std::string* _internal_mutable_topic();

  public:
  // @@protoc_insertion_point(class_scope:immo.ActuatorResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr topic_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fgRPC_2fimmo_2fimmo_2eproto;
};
// -------------------------------------------------------------------

class NodeResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:immo.NodeResponse) */ {
 public:
  inline NodeResponse() : NodeResponse(nullptr) {}
  ~NodeResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeResponse(const NodeResponse& from) : NodeResponse(nullptr, from) {}
  inline NodeResponse(NodeResponse&& from) noexcept
      : NodeResponse(nullptr, std::move(from)) {}
  inline NodeResponse& operator=(const NodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeResponse& operator=(NodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeResponse* internal_default_instance() {
    return reinterpret_cast<const NodeResponse*>(
        &_NodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(NodeResponse& a, NodeResponse& b) { a.Swap(&b); }
  inline void Swap(NodeResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NodeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeResponse& from) { NodeResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "immo.NodeResponse"; }

 protected:
  explicit NodeResponse(::google::protobuf::Arena* arena);
  NodeResponse(::google::protobuf::Arena* arena, const NodeResponse& from);
  NodeResponse(::google::protobuf::Arena* arena, NodeResponse&& from) noexcept
      : NodeResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSensorFieldNumber = 3,
    kActuatorFieldNumber = 4,
    kNameFieldNumber = 1,
    kIdFieldNumber = 2,
    kErrorFieldNumber = 5,
  };
  // repeated .immo.SensorResponse sensor = 3;
  int sensor_size() const;
  private:
  int _internal_sensor_size() const;

  public:
  void clear_sensor() ;
  ::immo::SensorResponse* mutable_sensor(int index);
  ::google::protobuf::RepeatedPtrField<::immo::SensorResponse>* mutable_sensor();

  private:
  const ::google::protobuf::RepeatedPtrField<::immo::SensorResponse>& _internal_sensor() const;
  ::google::protobuf::RepeatedPtrField<::immo::SensorResponse>* _internal_mutable_sensor();
  public:
  const ::immo::SensorResponse& sensor(int index) const;
  ::immo::SensorResponse* add_sensor();
  const ::google::protobuf::RepeatedPtrField<::immo::SensorResponse>& sensor() const;
  // repeated .immo.ActuatorResponse actuator = 4;
  int actuator_size() const;
  private:
  int _internal_actuator_size() const;

  public:
  void clear_actuator() ;
  ::immo::ActuatorResponse* mutable_actuator(int index);
  ::google::protobuf::RepeatedPtrField<::immo::ActuatorResponse>* mutable_actuator();

  private:
  const ::google::protobuf::RepeatedPtrField<::immo::ActuatorResponse>& _internal_actuator() const;
  ::google::protobuf::RepeatedPtrField<::immo::ActuatorResponse>* _internal_mutable_actuator();
  public:
  const ::immo::ActuatorResponse& actuator(int index) const;
  ::immo::ActuatorResponse* add_actuator();
  const ::google::protobuf::RepeatedPtrField<::immo::ActuatorResponse>& actuator() const;
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string id = 2;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string error = 5;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:immo.NodeResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::immo::SensorResponse > sensor_;
    ::google::protobuf::RepeatedPtrField< ::immo::ActuatorResponse > actuator_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fgRPC_2fimmo_2fimmo_2eproto;
};
// -------------------------------------------------------------------

class ListResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:immo.ListResponse) */ {
 public:
  inline ListResponse() : ListResponse(nullptr) {}
  ~ListResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListResponse(const ListResponse& from) : ListResponse(nullptr, from) {}
  inline ListResponse(ListResponse&& from) noexcept
      : ListResponse(nullptr, std::move(from)) {}
  inline ListResponse& operator=(const ListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListResponse& operator=(ListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListResponse* internal_default_instance() {
    return reinterpret_cast<const ListResponse*>(
        &_ListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ListResponse& a, ListResponse& b) { a.Swap(&b); }
  inline void Swap(ListResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ListResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListResponse& from) { ListResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "immo.ListResponse"; }

 protected:
  explicit ListResponse(::google::protobuf::Arena* arena);
  ListResponse(::google::protobuf::Arena* arena, const ListResponse& from);
  ListResponse(::google::protobuf::Arena* arena, ListResponse&& from) noexcept
      : ListResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodesFieldNumber = 1,
  };
  // repeated .immo.NodeResponse nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;

  public:
  void clear_nodes() ;
  ::immo::NodeResponse* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField<::immo::NodeResponse>* mutable_nodes();

  private:
  const ::google::protobuf::RepeatedPtrField<::immo::NodeResponse>& _internal_nodes() const;
  ::google::protobuf::RepeatedPtrField<::immo::NodeResponse>* _internal_mutable_nodes();
  public:
  const ::immo::NodeResponse& nodes(int index) const;
  ::immo::NodeResponse* add_nodes();
  const ::google::protobuf::RepeatedPtrField<::immo::NodeResponse>& nodes() const;
  // @@protoc_insertion_point(class_scope:immo.ListResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::immo::NodeResponse > nodes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fgRPC_2fimmo_2fimmo_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// NodeRequest

// string name = 1;
inline void NodeRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NodeRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:immo.NodeRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:immo.NodeRequest.name)
}
inline std::string* NodeRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:immo.NodeRequest.name)
  return _s;
}
inline const std::string& NodeRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void NodeRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* NodeRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* NodeRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:immo.NodeRequest.name)
  return _impl_.name_.Release();
}
inline void NodeRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:immo.NodeRequest.name)
}

// string address = 2;
inline void NodeRequest::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& NodeRequest::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:immo.NodeRequest.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeRequest::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:immo.NodeRequest.address)
}
inline std::string* NodeRequest::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:immo.NodeRequest.address)
  return _s;
}
inline const std::string& NodeRequest::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void NodeRequest::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.Set(value, GetArena());
}
inline std::string* NodeRequest::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* NodeRequest::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:immo.NodeRequest.address)
  return _impl_.address_.Release();
}
inline void NodeRequest::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:immo.NodeRequest.address)
}

// -------------------------------------------------------------------

// SensorResponse

// string name = 1;
inline void SensorResponse::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SensorResponse::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:immo.SensorResponse.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorResponse::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:immo.SensorResponse.name)
}
inline std::string* SensorResponse::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:immo.SensorResponse.name)
  return _s;
}
inline const std::string& SensorResponse::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void SensorResponse::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* SensorResponse::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* SensorResponse::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:immo.SensorResponse.name)
  return _impl_.name_.Release();
}
inline void SensorResponse::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:immo.SensorResponse.name)
}

// string topic = 2;
inline void SensorResponse::clear_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.ClearToEmpty();
}
inline const std::string& SensorResponse::topic() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:immo.SensorResponse.topic)
  return _internal_topic();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorResponse::set_topic(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:immo.SensorResponse.topic)
}
inline std::string* SensorResponse::mutable_topic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:immo.SensorResponse.topic)
  return _s;
}
inline const std::string& SensorResponse::_internal_topic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topic_.Get();
}
inline void SensorResponse::_internal_set_topic(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.Set(value, GetArena());
}
inline std::string* SensorResponse::_internal_mutable_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.topic_.Mutable( GetArena());
}
inline std::string* SensorResponse::release_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:immo.SensorResponse.topic)
  return _impl_.topic_.Release();
}
inline void SensorResponse::set_allocated_topic(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topic_.IsDefault()) {
          _impl_.topic_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:immo.SensorResponse.topic)
}

// -------------------------------------------------------------------

// ActuatorResponse

// string name = 1;
inline void ActuatorResponse::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ActuatorResponse::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:immo.ActuatorResponse.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ActuatorResponse::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:immo.ActuatorResponse.name)
}
inline std::string* ActuatorResponse::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:immo.ActuatorResponse.name)
  return _s;
}
inline const std::string& ActuatorResponse::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ActuatorResponse::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ActuatorResponse::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ActuatorResponse::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:immo.ActuatorResponse.name)
  return _impl_.name_.Release();
}
inline void ActuatorResponse::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:immo.ActuatorResponse.name)
}

// string topic = 2;
inline void ActuatorResponse::clear_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.ClearToEmpty();
}
inline const std::string& ActuatorResponse::topic() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:immo.ActuatorResponse.topic)
  return _internal_topic();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ActuatorResponse::set_topic(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:immo.ActuatorResponse.topic)
}
inline std::string* ActuatorResponse::mutable_topic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:immo.ActuatorResponse.topic)
  return _s;
}
inline const std::string& ActuatorResponse::_internal_topic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topic_.Get();
}
inline void ActuatorResponse::_internal_set_topic(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.Set(value, GetArena());
}
inline std::string* ActuatorResponse::_internal_mutable_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.topic_.Mutable( GetArena());
}
inline std::string* ActuatorResponse::release_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:immo.ActuatorResponse.topic)
  return _impl_.topic_.Release();
}
inline void ActuatorResponse::set_allocated_topic(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topic_.IsDefault()) {
          _impl_.topic_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:immo.ActuatorResponse.topic)
}

// -------------------------------------------------------------------

// NodeResponse

// string name = 1;
inline void NodeResponse::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NodeResponse::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:immo.NodeResponse.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeResponse::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:immo.NodeResponse.name)
}
inline std::string* NodeResponse::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:immo.NodeResponse.name)
  return _s;
}
inline const std::string& NodeResponse::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void NodeResponse::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* NodeResponse::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* NodeResponse::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:immo.NodeResponse.name)
  return _impl_.name_.Release();
}
inline void NodeResponse::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:immo.NodeResponse.name)
}

// string id = 2;
inline void NodeResponse::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& NodeResponse::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:immo.NodeResponse.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeResponse::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:immo.NodeResponse.id)
}
inline std::string* NodeResponse::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:immo.NodeResponse.id)
  return _s;
}
inline const std::string& NodeResponse::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void NodeResponse::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* NodeResponse::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* NodeResponse::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:immo.NodeResponse.id)
  return _impl_.id_.Release();
}
inline void NodeResponse::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:immo.NodeResponse.id)
}

// repeated .immo.SensorResponse sensor = 3;
inline int NodeResponse::_internal_sensor_size() const {
  return _internal_sensor().size();
}
inline int NodeResponse::sensor_size() const {
  return _internal_sensor_size();
}
inline void NodeResponse::clear_sensor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sensor_.Clear();
}
inline ::immo::SensorResponse* NodeResponse::mutable_sensor(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:immo.NodeResponse.sensor)
  return _internal_mutable_sensor()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::immo::SensorResponse>* NodeResponse::mutable_sensor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:immo.NodeResponse.sensor)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_sensor();
}
inline const ::immo::SensorResponse& NodeResponse::sensor(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:immo.NodeResponse.sensor)
  return _internal_sensor().Get(index);
}
inline ::immo::SensorResponse* NodeResponse::add_sensor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::immo::SensorResponse* _add = _internal_mutable_sensor()->Add();
  // @@protoc_insertion_point(field_add:immo.NodeResponse.sensor)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::immo::SensorResponse>& NodeResponse::sensor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:immo.NodeResponse.sensor)
  return _internal_sensor();
}
inline const ::google::protobuf::RepeatedPtrField<::immo::SensorResponse>&
NodeResponse::_internal_sensor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sensor_;
}
inline ::google::protobuf::RepeatedPtrField<::immo::SensorResponse>*
NodeResponse::_internal_mutable_sensor() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.sensor_;
}

// repeated .immo.ActuatorResponse actuator = 4;
inline int NodeResponse::_internal_actuator_size() const {
  return _internal_actuator().size();
}
inline int NodeResponse::actuator_size() const {
  return _internal_actuator_size();
}
inline void NodeResponse::clear_actuator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.actuator_.Clear();
}
inline ::immo::ActuatorResponse* NodeResponse::mutable_actuator(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:immo.NodeResponse.actuator)
  return _internal_mutable_actuator()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::immo::ActuatorResponse>* NodeResponse::mutable_actuator()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:immo.NodeResponse.actuator)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_actuator();
}
inline const ::immo::ActuatorResponse& NodeResponse::actuator(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:immo.NodeResponse.actuator)
  return _internal_actuator().Get(index);
}
inline ::immo::ActuatorResponse* NodeResponse::add_actuator() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::immo::ActuatorResponse* _add = _internal_mutable_actuator()->Add();
  // @@protoc_insertion_point(field_add:immo.NodeResponse.actuator)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::immo::ActuatorResponse>& NodeResponse::actuator() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:immo.NodeResponse.actuator)
  return _internal_actuator();
}
inline const ::google::protobuf::RepeatedPtrField<::immo::ActuatorResponse>&
NodeResponse::_internal_actuator() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.actuator_;
}
inline ::google::protobuf::RepeatedPtrField<::immo::ActuatorResponse>*
NodeResponse::_internal_mutable_actuator() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.actuator_;
}

// string error = 5;
inline void NodeResponse::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.ClearToEmpty();
}
inline const std::string& NodeResponse::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:immo.NodeResponse.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeResponse::set_error(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:immo.NodeResponse.error)
}
inline std::string* NodeResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:immo.NodeResponse.error)
  return _s;
}
inline const std::string& NodeResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_.Get();
}
inline void NodeResponse::_internal_set_error(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.Set(value, GetArena());
}
inline std::string* NodeResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* NodeResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:immo.NodeResponse.error)
  return _impl_.error_.Release();
}
inline void NodeResponse::set_allocated_error(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:immo.NodeResponse.error)
}

// -------------------------------------------------------------------

// ListResponse

// repeated .immo.NodeResponse nodes = 1;
inline int ListResponse::_internal_nodes_size() const {
  return _internal_nodes().size();
}
inline int ListResponse::nodes_size() const {
  return _internal_nodes_size();
}
inline void ListResponse::clear_nodes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nodes_.Clear();
}
inline ::immo::NodeResponse* ListResponse::mutable_nodes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:immo.ListResponse.nodes)
  return _internal_mutable_nodes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::immo::NodeResponse>* ListResponse::mutable_nodes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:immo.ListResponse.nodes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_nodes();
}
inline const ::immo::NodeResponse& ListResponse::nodes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:immo.ListResponse.nodes)
  return _internal_nodes().Get(index);
}
inline ::immo::NodeResponse* ListResponse::add_nodes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::immo::NodeResponse* _add = _internal_mutable_nodes()->Add();
  // @@protoc_insertion_point(field_add:immo.ListResponse.nodes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::immo::NodeResponse>& ListResponse::nodes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:immo.ListResponse.nodes)
  return _internal_nodes();
}
inline const ::google::protobuf::RepeatedPtrField<::immo::NodeResponse>&
ListResponse::_internal_nodes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nodes_;
}
inline ::google::protobuf::RepeatedPtrField<::immo::NodeResponse>*
ListResponse::_internal_mutable_nodes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.nodes_;
}

// -------------------------------------------------------------------

// ListRequest

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace immo


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fgRPC_2fimmo_2fimmo_2eproto_2epb_2eh
